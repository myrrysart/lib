=================================
MAN PAGE FOR: atoi
=================================

ATOI(3)                                                          Linux Programmer's Manual                                                          ATOI(3)

NAME
       atoi, atol, atoll - convert a string to an integer

SYNOPSIS
       #include <stdlib.h>

       int atoi(const char *nptr);
       long atol(const char *nptr);
       long long atoll(const char *nptr);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       atoll():
           _ISOC99_SOURCE ||
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE || _SVID_SOURCE

DESCRIPTION
       The atoi() function converts the initial portion of the string pointed to by nptr to int.  The behavior is the same as

           strtol(nptr, NULL, 10);

       except that atoi() does not detect errors.

       The  atol() and atoll() functions behave the same as atoi(), except that they convert the initial portion of the string to their return type of long
       or long long.

RETURN VALUE
       The converted value or 0 on error.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌────────────────────────┬───────────────┬────────────────┐
       │Interface               │ Attribute     │ Value          │
       ├────────────────────────┼───────────────┼────────────────┤
       │atoi(), atol(), atoll() │ Thread safety │ MT-Safe locale │
       └────────────────────────┴───────────────┴────────────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, C99, SVr4, 4.3BSD.  C89 and POSIX.1-1996 include the functions atoi() and atol() only.

NOTES
       POSIX.1 leaves the return value of atoi() on error unspecified.  On glibc, musl libc, and uClibc, 0 is returned on error.

BUGS
       errno is not set on error so there is no way to distinguish between 0 as an error and as the converted value.  No checks for overflow  or  underflow
       are done.  Only base-10 input can be converted.  It is recommended to instead use the strtol() and strtoul() family of functions in new programs.

SEE ALSO
       atof(3), strtod(3), strtol(3), strtoul(3)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2020-08-13                                                                 ATOI(3)

=================================
MAN PAGE FOR: strtol
=================================

STRTOL(3)                                                        Linux Programmer's Manual                                                        STRTOL(3)

NAME
       strtol, strtoll, strtoq - convert a string to a long integer

SYNOPSIS
       #include <stdlib.h>

       long strtol(const char *nptr, char **endptr, int base);

       long long strtoll(const char *nptr, char **endptr, int base);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       strtoll():
           _ISOC99_SOURCE
               || /* Glibc versions <= 2.19: */ _SVID_SOURCE || _BSD_SOURCE

DESCRIPTION
       The  strtol()  function converts the initial part of the string in nptr to a long integer value according to the given base, which must be between 2
       and 36 inclusive, or be the special value 0.

       The string may begin with an arbitrary amount of white space (as determined by isspace(3)) followed by a single optional '+' or '-' sign.   If  base
       is  zero  or  16,  the  string may then include a "0x" or "0X" prefix, and the number will be read in base 16; otherwise, a zero base is taken as 10
       (decimal) unless the next character is '0', in which case it is taken as 8 (octal).

       The remainder of the string is converted to a long value in the obvious manner, stopping at the first character which is not a valid  digit  in  the
       given base.  (In bases above 10, the letter 'A' in either uppercase or lowercase represents 10, 'B' represents 11, and so forth, with 'Z' represent‐
       ing 35.)

       If endptr is not NULL, strtol() stores the address of the first invalid character in *endptr.  If there were no digits at all, strtol()  stores  the
       original value of nptr in *endptr (and returns 0).  In particular, if *nptr is not '\0' but **endptr is '\0' on return, the entire string is valid.

       The strtoll() function works just like the strtol() function but returns a long long integer value.

RETURN VALUE
       The  strtol() function returns the result of the conversion, unless the value would underflow or overflow.  If an underflow occurs, strtol() returns
       LONG_MIN.  If an overflow occurs, strtol() returns LONG_MAX.  In both cases, errno is set to ERANGE.  Precisely the same holds for  strtoll()  (with
       LLONG_MIN and LLONG_MAX instead of LONG_MIN and LONG_MAX).

ERRORS
       EINVAL (not in C99) The given base contains an unsupported value.

       ERANGE The resulting value was out of range.

       The implementation may also set errno to EINVAL in case no conversion was performed (no digits seen, and 0 returned).

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌──────────────────────────────┬───────────────┬────────────────┐
       │Interface                     │ Attribute     │ Value          │
       ├──────────────────────────────┼───────────────┼────────────────┤
       │strtol(), strtoll(), strtoq() │ Thread safety │ MT-Safe locale │
       └──────────────────────────────┴───────────────┴────────────────┘
CONFORMING TO
       strtol(): POSIX.1-2001, POSIX.1-2008, C89, C99 SVr4, 4.3BSD.

       strtoll(): POSIX.1-2001, POSIX.1-2008, C99.

NOTES
       Since strtol() can legitimately return 0, LONG_MAX, or LONG_MIN (LLONG_MAX or LLONG_MIN for strtoll()) on both success and failure, the calling pro‐
       gram should set errno to 0 before the call, and then determine if an error occurred by checking whether errno has a nonzero value after the call.

       According to POSIX.1, in locales other than "C" and "POSIX", these functions may accept other, implementation-defined numeric strings.

       BSD also has

           quad_t strtoq(const char *nptr, char **endptr, int base);

       with completely analogous definition.  Depending on the wordsize of the current architecture, this may be equivalent to strtoll() or to strtol().

EXAMPLES
       The program shown below demonstrates the use of strtol().  The first command-line argument specifies a string from which  strtol()  should  parse  a
       number.   The  second  (optional)  argument  specifies  the  base  to be used for the conversion.  (This argument is converted to numeric form using
       atoi(3), a function that performs no error checking and has a simpler interface than strtol().)  Some examples of the results produced by this  pro‐
       gram are the following:

           $ ./a.out 123
           strtol() returned 123
           $ ./a.out '    123'
           strtol() returned 123
           $ ./a.out 123abc
           strtol() returned 123
           Further characters after number: "abc"
           $ ./a.out 123abc 55
           strtol: Invalid argument
           $ ./a.out ''
           No digits were found
           $ ./a.out 4000000000
           strtol: Numerical result out of range

   Program source

       #include <stdlib.h>
       #include <limits.h>
       #include <stdio.h>
       #include <errno.h>

       int
       main(int argc, char *argv[])
       {
           int base;
           char *endptr, *str;
           long val;

           if (argc < 2) {
               fprintf(stderr, "Usage: %s str [base]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           str = argv[1];
           base = (argc > 2) ? atoi(argv[2]) : 0;

           errno = 0;    /* To distinguish success/failure after call */
           val = strtol(str, &endptr, base);

           /* Check for various possible errors */

           if (errno != 0) {
               perror("strtol");
               exit(EXIT_FAILURE);
           }

           if (endptr == str) {
               fprintf(stderr, "No digits were found\n");
               exit(EXIT_FAILURE);
           }

           /* If we got here, strtol() successfully parsed a number */

           printf("strtol() returned %ld\n", val);

           if (*endptr != '\0')        /* Not necessarily an error... */
               printf("Further characters after number: \"%s\"\n", endptr);

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       atof(3), atoi(3), atol(3), strtod(3), strtoimax(3), strtoul(3),

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2020-11-01                                                               STRTOL(3)

=================================
MAN PAGE FOR: bzero
=================================

BZERO(3)                                                         Linux Programmer's Manual                                                         BZERO(3)

NAME
       bzero, explicit_bzero - zero a byte string

SYNOPSIS
       #include <strings.h>

       void bzero(void *s, size_t n);

       #include <string.h>

       void explicit_bzero(void *s, size_t n);

DESCRIPTION
       The bzero() function erases the data in the n bytes of the memory starting at the location pointed to by s, by writing zeros (bytes containing '\0')
       to that area.

       The explicit_bzero() function performs the same task as bzero().  It differs from bzero() in that it guarantees that compiler optimizations will not
       remove the erase operation if the compiler deduces that the operation is "unnecessary".

RETURN VALUE
       None.

VERSIONS
       explicit_bzero() first appeared in glibc 2.25.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌─────────────────┬───────────────┬─────────┐
       │Interface        │ Attribute     │ Value   │
       ├─────────────────┼───────────────┼─────────┤
       │bzero(),         │ Thread safety │ MT-Safe │
       │explicit_bzero() │               │         │
       └─────────────────┴───────────────┴─────────┘
CONFORMING TO
       The  bzero()  function  is  deprecated (marked as LEGACY in POSIX.1-2001); use memset(3) in new programs.  POSIX.1-2008 removes the specification of
       bzero().  The bzero() function first appeared in 4.3BSD.

       The explicit_bzero() function is a nonstandard extension that is also present on some of the BSDs.  Some other implementations have a similar  func‐
       tion, such as memset_explicit() or memset_s().

NOTES
       The  explicit_bzero()  function addresses a problem that security-conscious applications may run into when using bzero(): if the compiler can deduce
       that the location to zeroed will never again be touched by a correct program, then it may remove the bzero() call altogether.  This is a problem  if
       the  intent of the bzero() call was to erase sensitive data (e.g., passwords) to prevent the possibility that the data was leaked by an incorrect or
       compromised program.  Calls to explicit_bzero() are never optimized away by the compiler.

       The explicit_bzero() function does not solve all problems associated with erasing sensitive data:

       1. The explicit_bzero() function does not guarantee that sensitive data is completely erased from memory.  (The same is true of bzero().)  For exam‐
          ple,  there  may be copies of the sensitive data in a register and in "scratch" stack areas.  The explicit_bzero() function is not aware of these
          copies, and can't erase them.

       2. In some circumstances, explicit_bzero() can decrease security.  If the compiler determined that the variable containing the sensitive data  could
          be  optimized  to be stored in a register (because it is small enough to fit in a register, and no operation other than the explicit_bzero() call
          would need to take the address of the variable), then the explicit_bzero() call will force the data to be copied from the register to a  location
          in  RAM that is then immediately erased (while the copy in the register remains unaffected).  The problem here is that data in RAM is more likely
          to be exposed by a bug than data in a register, and thus the explicit_bzero() call creates a brief time window where the sensitive data  is  more
          vulnerable than it would otherwise have been if no attempt had been made to erase the data.

       Note  that  declaring  the  sensitive  variable with the volatile qualifier does not eliminate the above problems.  Indeed, it will make them worse,
       since, for example, it may force a variable that would otherwise have been optimized into a register to instead be maintained in  (more  vulnerable)
       RAM for its entire lifetime.

       Notwithstanding  the above details, for security-conscious applications, using explicit_bzero() is generally preferable to not using it.  The devel‐
       opers of explicit_bzero() anticipate that future compilers will recognize calls to explicit_bzero() and take steps to ensure that all copies of  the
       sensitive data are erased, including copies in registers or in "scratch" stack areas.

SEE ALSO
       bstring(3), memset(3), swab(3)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                                    2019-03-06                                                                BZERO(3)

=================================
MAN PAGE FOR: calloc
=================================

MALLOC(3)                                                        Linux Programmer's Manual                                                        MALLOC(3)

NAME
       malloc, free, calloc, realloc, reallocarray - allocate and free dynamic memory

SYNOPSIS
       #include <stdlib.h>

       void *malloc(size_t size);
       void free(void *ptr);
       void *calloc(size_t nmemb, size_t size);
       void *realloc(void *ptr, size_t size);
       void *reallocarray(void *ptr, size_t nmemb, size_t size);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       reallocarray():
           Since glibc 2.29:
               _DEFAULT_SOURCE
           Glibc 2.28 and earlier:
               _GNU_SOURCE

DESCRIPTION
       The  malloc()  function allocates size bytes and returns a pointer to the allocated memory.  The memory is not initialized.  If size is 0, then mal‐
       loc() returns either NULL, or a unique pointer value that can later be successfully passed to free().

       The free() function frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc(), calloc(), or  realloc().
       Otherwise, or if free(ptr) has already been called before, undefined behavior occurs.  If ptr is NULL, no operation is performed.

       The  calloc() function allocates memory for an array of nmemb elements of size bytes each and returns a pointer to the allocated memory.  The memory
       is set to zero.  If nmemb or size is 0, then calloc() returns either NULL, or a unique pointer value  that  can  later  be  successfully  passed  to
       free().  If the multiplication of nmemb and size would result in integer overflow, then calloc() returns an error.  By contrast, an integer overflow
       would not be detected in the following call to malloc(), with the result that an incorrectly sized block of memory would be allocated:

           malloc(nmemb * size);

       The realloc() function changes the size of the memory block pointed to by ptr to size bytes.  The contents will be unchanged in the range  from  the
       start  of the region up to the minimum of the old and new sizes.  If the new size is larger than the old size, the added memory will not be initial‐
       ized.  If ptr is NULL, then the call is equivalent to malloc(size), for all values of size; if size is equal to zero, and ptr is not NULL, then  the
       call  is  equivalent  to  free(ptr).  Unless ptr is NULL, it must have been returned by an earlier call to malloc(), calloc(), or realloc().  If the
       area pointed to was moved, a free(ptr) is done.

       The reallocarray() function changes the size of the memory block pointed to by ptr to be large enough for an array of nmemb elements, each of  which
       is size bytes.  It is equivalent to the call

               realloc(ptr, nmemb * size);

       However,  unlike  that realloc() call, reallocarray() fails safely in the case where the multiplication would overflow.  If such an overflow occurs,
       reallocarray() returns NULL, sets errno to ENOMEM, and leaves the original block of memory unchanged.

RETURN VALUE
       The malloc() and calloc() functions return a pointer to the allocated memory, which is suitably aligned for any  built-in  type.   On  error,  these
       functions  return  NULL.   NULL  may also be returned by a successful call to malloc() with a size of zero, or by a successful call to calloc() with
       nmemb or size equal to zero.

       The free() function returns no value.

       The realloc() function returns a pointer to the newly allocated memory, which is suitably aligned for any built-in type,  or  NULL  if  the  request
       failed.   The  returned  pointer may be the same as ptr if the allocation was not moved (e.g., there was room to expand the allocation in-place), or
       different from ptr if the allocation was moved to a new address.  If size was equal to 0, either NULL or a pointer suitable to be passed  to  free()
       is returned.  If realloc() fails, the original block is left untouched; it is not freed or moved.

       On success, the reallocarray() function returns a pointer to the newly allocated memory.  On failure, it returns NULL and the original block of mem‐
       ory is left untouched.

ERRORS
       calloc(), malloc(), realloc(), and reallocarray() can fail with the following error:

       ENOMEM Out of memory.  Possibly, the application hit the RLIMIT_AS or RLIMIT_DATA limit described in getrlimit(2).

VERSIONS
       reallocarray() first appeared in glibc in version 2.26.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌─────────────────────┬───────────────┬─────────┐
       │Interface            │ Attribute     │ Value   │
       ├─────────────────────┼───────────────┼─────────┤
       │malloc(), free(),    │ Thread safety │ MT-Safe │
       │calloc(), realloc()  │               │         │
       └─────────────────────┴───────────────┴─────────┘
CONFORMING TO
       malloc(), free(), calloc(), realloc(): POSIX.1-2001, POSIX.1-2008, C89, C99.

       reallocarray() is a nonstandard extension that first appeared in OpenBSD 5.6 and FreeBSD 11.0.

NOTES
       By default, Linux follows an optimistic memory allocation strategy.  This means that when malloc() returns non-NULL there is no guarantee  that  the
       memory  really  is  available.   In case it turns out that the system is out of memory, one or more processes will be killed by the OOM killer.  For
       more information, see the description of /proc/sys/vm/overcommit_memory and /proc/sys/vm/oom_adj in proc(5), and the Linux kernel source file  Docu‐
       mentation/vm/overcommit-accounting.rst.

       Normally,  malloc()  allocates  memory from the heap, and adjusts the size of the heap as required, using sbrk(2).  When allocating blocks of memory
       larger than MMAP_THRESHOLD bytes, the glibc malloc() implementation allocates the memory as a private anonymous mapping using mmap(2).  MMAP_THRESH‐
       OLD  is  128 kB  by  default,  but  is  adjustable  using mallopt(3).  Prior to Linux 4.7 allocations performed using mmap(2) were unaffected by the
       RLIMIT_DATA resource limit; since Linux 4.7, this limit is also enforced for allocations performed using mmap(2).

       To avoid corruption in multithreaded applications, mutexes are used internally to protect the memory-management data structures  employed  by  these
       functions.   In  a  multithreaded application in which threads simultaneously allocate and free memory, there could be contention for these mutexes.
       To scalably handle memory allocation in multithreaded applications, glibc creates additional memory allocation arenas if  mutex  contention  is  de‐
       tected.   Each  arena is a large region of memory that is internally allocated by the system (using brk(2) or mmap(2)), and managed with its own mu‐
       texes.

       SUSv2 requires malloc(), calloc(), and realloc() to set errno to ENOMEM upon failure.  Glibc assumes that this is done (and the  glibc  versions  of
       these routines do this); if you use a private malloc implementation that does not set errno, then certain library routines may fail without having a
       reason in errno.

       Crashes in malloc(), calloc(), realloc(), or free() are almost always related to heap corruption, such as overflowing an allocated chunk or  freeing
       the same pointer twice.

       The malloc() implementation is tunable via environment variables; see mallopt(3) for details.

SEE ALSO
       valgrind(1), brk(2), mmap(2), alloca(3), malloc_get_state(3), malloc_info(3), malloc_trim(3), malloc_usable_size(3), mallopt(3), mcheck(3),
       mtrace(3), posix_memalign(3)

       For details of the GNU C library implementation, see ⟨https://sourceware.org/glibc/wiki/MallocInternals⟩.

COLOPHON
       This page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2020-06-09                                                               MALLOC(3)

=================================
MAN PAGE FOR: isalnum
=================================
=================================
MAN PAGE FOR: isalpha
=================================
=================================
MAN PAGE FOR: isascii
=================================
=================================
MAN PAGE FOR: isdigit
=================================
=================================
MAN PAGE FOR: isprint
=================================

ISALPHA(3)                                                       Linux Programmer's Manual                                                       ISALPHA(3)

NAME
       isalnum,  isalpha,  isascii,  isblank, iscntrl, isdigit, isgraph, islower, isprint, ispunct, isspace, isupper, isxdigit, isalnum_l, isalpha_l, isas‐
       cii_l, isblank_l, iscntrl_l, isdigit_l, isgraph_l, islower_l, isprint_l, ispunct_l, isspace_l,  isupper_l,  isxdigit_l  -  character  classification
       functions

SYNOPSIS
       #include <ctype.h>

       int isalnum(int c);
       int isalpha(int c);
       int iscntrl(int c);
       int isdigit(int c);
       int isgraph(int c);
       int islower(int c);
       int isprint(int c);
       int ispunct(int c);
       int isspace(int c);
       int isupper(int c);
       int isxdigit(int c);

       int isascii(int c);
       int isblank(int c);

       int isalnum_l(int c, locale_t locale);
       int isalpha_l(int c, locale_t locale);
       int isblank_l(int c, locale_t locale);
       int iscntrl_l(int c, locale_t locale);
       int isdigit_l(int c, locale_t locale);
       int isgraph_l(int c, locale_t locale);
       int islower_l(int c, locale_t locale);
       int isprint_l(int c, locale_t locale);
       int ispunct_l(int c, locale_t locale);
       int isspace_l(int c, locale_t locale);
       int isupper_l(int c, locale_t locale);
       int isxdigit_l(int c, locale_t locale);

       int isascii_l(int c, locale_t locale);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       isascii():
           _XOPEN_SOURCE
               || /* Glibc since 2.19: */ _DEFAULT_SOURCE
               || /* Glibc versions <= 2.19: */ _SVID_SOURCE

       isblank():
           _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L

       isalnum_l(), isalpha_l(), isblank_l(), iscntrl_l(), isdigit_l(), isgraph_l(), islower_l(), isprint_l(), ispunct_l(), isspace_l(), isupper_l(),
       isxdigit_l():
           Since glibc 2.10:
                  _XOPEN_SOURCE >= 700
           Before glibc 2.10:
                  _GNU_SOURCE

       isascii_l():
           Since glibc 2.10:
                  _XOPEN_SOURCE >= 700 && (_SVID_SOURCE || _BSD_SOURCE)
           Before glibc 2.10:
                  _GNU_SOURCE

DESCRIPTION
       These functions check whether c, which must have the value of an unsigned char or EOF, falls into a certain character class according to the  speci‐
       fied locale.  The functions without the "_l" suffix perform the check based on the current locale.

       The  functions with the "_l" suffix perform the check based on the locale specified by the locale object locale.  The behavior of these functions is
       undefined if locale is the special locale object LC_GLOBAL_LOCALE (see duplocale(3)) or is not a valid locale object handle.

       The list below explains the operation of the functions without the "_l" suffix; the functions with the "_l" suffix differ only in using  the  locale
       object locale instead of the current locale.

       isalnum()
              checks for an alphanumeric character; it is equivalent to (isalpha(c) || isdigit(c)).

       isalpha()
              checks  for  an alphabetic character; in the standard "C" locale, it is equivalent to (isupper(c) || islower(c)).  In some locales, there may
              be additional characters for which isalpha() is true—letters which are neither uppercase nor lowercase.

       isascii()
              checks whether c is a 7-bit unsigned char value that fits into the ASCII character set.

       isblank()
              checks for a blank character; that is, a space or a tab.

       iscntrl()
              checks for a control character.

       isdigit()
              checks for a digit (0 through 9).

       isgraph()
              checks for any printable character except space.

       islower()
              checks for a lowercase character.

       isprint()
              checks for any printable character including space.

       ispunct()
              checks for any printable character which is not a space or an alphanumeric character.

       isspace()
              checks for white-space characters.  In the "C" and "POSIX" locales, these are: space,  form-feed  ('\f'),  newline  ('\n'),  carriage  return
              ('\r'), horizontal tab ('\t'), and vertical tab ('\v').

       isupper()
              checks for an uppercase letter.

       isxdigit()
              checks for hexadecimal digits, that is, one of
              0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F.

RETURN VALUE
       The values returned are nonzero if the character c falls into the tested class, and zero if not.

VERSIONS
       isalnum_l(),  isalpha_l(),  isblank_l(),  iscntrl_l(),  isdigit_l(),  isgraph_l(),  islower_l(), isprint_l(), ispunct_l(), isspace_l(), isupper_l(),
       isxdigit_l(), and isascii_l() are available since glibc 2.3.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌─────────────────────────────────┬───────────────┬─────────┐
       │Interface                        │ Attribute     │ Value   │
       ├─────────────────────────────────┼───────────────┼─────────┤
       │isalnum(), isalpha(), isascii(), │ Thread safety │ MT-Safe │
       │isblank(), iscntrl(), isdigit(), │               │         │
       │isgraph(), islower(), isprint(), │               │         │
       │ispunct(), isspace(), isupper(), │               │         │
       │isxdigit()                       │               │         │
       └─────────────────────────────────┴───────────────┴─────────┘
CONFORMING TO
       C89 specifies isalnum(), isalpha(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), and isxdigit(), but  not
       isascii() and isblank().  POSIX.1-2001 also specifies those functions, and also isascii() (as an XSI extension) and isblank().  C99 specifies all of
       the preceding functions, except isascii().

       POSIX.1-2008 marks isascii() as obsolete, noting that it cannot be used portably in a localized application.

       POSIX.1-2008 specifies isalnum_l(), isalpha_l(), isblank_l(), iscntrl_l(), isdigit_l(), isgraph_l(),  islower_l(),  isprint_l(),  ispunct_l(),  iss‐
       pace_l(), isupper_l(), and isxdigit_l().

       isascii_l() is a GNU extension.

NOTES
       The  standards require that the argument c for these functions is either EOF or a value that is representable in the type unsigned char.  If the ar‐
       gument c is of type char, it must be cast to unsigned char, as in the following example:

           char c;
           ...
           res = toupper((unsigned char) c);

       This is necessary because char may be the equivalent of signed char, in which case a byte where the top bit is set would be sign extended when  con‐
       verting to int, yielding a value that is outside the range of unsigned char.

       The  details  of what characters belong to which class depend on the locale.  For example, isupper() will not recognize an A-umlaut (Ä) as an upper‐
       case letter in the default C locale.

SEE ALSO
       iswalnum(3), iswalpha(3), iswblank(3), iswcntrl(3), iswdigit(3),  iswgraph(3),  iswlower(3),  iswprint(3),  iswpunct(3),  iswspace(3),  iswupper(3),
       iswxdigit(3), newlocale(3), setlocale(3), toascii(3), tolower(3), toupper(3), uselocale(3), ascii(7), locale(7)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2017-09-15                                                              ISALPHA(3)

=================================
MAN PAGE FOR: itoa
=================================
Function name ft_itoa
Prototype char *ft_itoa(int n);
Turn in files -
Parameters n: the integer to convert.
Return value The string representing the integer.
NULL if the allocation fails.
External functs. malloc
Description Allocates (with malloc(3)) and returns a string
representing the integer received as an argument.
Negative numbers must be handled.

No manual entry found for itoa

=================================
MAN PAGE FOR: lstadd_back
=================================

No manual entry found for lstadd_back

=================================
MAN PAGE FOR: lstadd_front
=================================

No manual entry found for lstadd_front

=================================
MAN PAGE FOR: lstclear
=================================

No manual entry found for lstclear

=================================
MAN PAGE FOR: lstdelone
=================================

No manual entry found for lstdelone

=================================
MAN PAGE FOR: lstiter
=================================

No manual entry found for lstiter

=================================
MAN PAGE FOR: lstlast
=================================

No manual entry found for lstlast

=================================
MAN PAGE FOR: lstmap
=================================

No manual entry found for lstmap

=================================
MAN PAGE FOR: lstnew
=================================

No manual entry found for lstnew

=================================
MAN PAGE FOR: lstsize
=================================

No manual entry found for lstsize

=================================
MAN PAGE FOR: memchr
=================================

MEMCHR(3)                                                        Linux Programmer's Manual                                                        MEMCHR(3)

NAME
       memchr, memrchr, rawmemchr - scan memory for a character

SYNOPSIS
       #include <string.h>

       void *memchr(const void *s, int c, size_t n);

       void *memrchr(const void *s, int c, size_t n);

       void *rawmemchr(const void *s, int c);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       memrchr(), rawmemchr(): _GNU_SOURCE

DESCRIPTION
       The  memchr() function scans the initial n bytes of the memory area pointed to by s for the first instance of c.  Both c and the bytes of the memory
       area pointed to by s are interpreted as unsigned char.

       The memrchr() function is like the memchr() function, except that it searches backward from the end of the n bytes pointed to by s instead  of  for‐
       ward from the beginning.

       The  rawmemchr()  function  is  similar to memchr(): it assumes (i.e., the programmer knows for certain) that an instance of c lies somewhere in the
       memory area starting at the location pointed to by s, and so performs an optimized search for c (i.e., no use of a count argument to limit the range
       of  the search).  If an instance of c is not found, the results are unpredictable.  The following call is a fast means of locating a string's termi‐
       nating null byte:

           char *p = rawmemchr(s, '\0');

RETURN VALUE
       The memchr() and memrchr() functions return a pointer to the matching byte or NULL if the character does not occur in the given memory area.

       The rawmemchr() function returns a pointer to the matching byte, if one is found.  If no matching byte is found, the result is unspecified.

VERSIONS
       rawmemchr() first appeared in glibc in version 2.1.

       memrchr() first appeared in glibc in version 2.2.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌─────────────────────────────────┬───────────────┬─────────┐
       │Interface                        │ Attribute     │ Value   │
       ├─────────────────────────────────┼───────────────┼─────────┤
       │memchr(), memrchr(), rawmemchr() │ Thread safety │ MT-Safe │
       └─────────────────────────────────┴───────────────┴─────────┘
CONFORMING TO
       memchr(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

       The memrchr() function is a GNU extension, available since glibc 2.1.91.

       The rawmemchr() function is a GNU extension, available since glibc 2.1.

SEE ALSO
       bstring(3), ffs(3), index(3), memmem(3), rindex(3), strchr(3), strpbrk(3), strrchr(3), strsep(3), strspn(3), strstr(3), wmemchr(3)

COLOPHON
       This page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs,  and  the  latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

                                                                         2019-03-06                                                               MEMCHR(3)

=================================
MAN PAGE FOR: memcmp
=================================

MEMCMP(3)                                                        Linux Programmer's Manual                                                        MEMCMP(3)

NAME
       memcmp - compare memory areas

SYNOPSIS
       #include <string.h>

       int memcmp(const void *s1, const void *s2, size_t n);

DESCRIPTION
       The memcmp() function compares the first n bytes (each interpreted as unsigned char) of the memory areas s1 and s2.

RETURN VALUE
       The  memcmp()  function  returns  an integer less than, equal to, or greater than zero if the first n bytes of s1 is found, respectively, to be less
       than, to match, or be greater than the first n bytes of s2.

       For a nonzero return value, the sign is determined by the sign of the difference between the first pair of bytes (interpreted as unsigned char) that
       differ in s1 and s2.

       If n is zero, the return value is zero.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌──────────┬───────────────┬─────────┐
       │Interface │ Attribute     │ Value   │
       ├──────────┼───────────────┼─────────┤
       │memcmp()  │ Thread safety │ MT-Safe │
       └──────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

NOTES
       Do  not  use memcmp() to compare security critical data, such as cryptographic secrets, because the required CPU time depends on the number of equal
       bytes.  Instead, a function that performs comparisons in constant time is required.  Some operating systems provide such a function (e.g.,  NetBSD's
       consttime_memequal()), but no such function is specified in POSIX.  On Linux, it may be necessary to implement such a function oneself.

SEE ALSO
       bcmp(3), bstring(3), strcasecmp(3), strcmp(3), strcoll(3), strncasecmp(3), strncmp(3), wmemcmp(3)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

                                                                         2017-09-15                                                               MEMCMP(3)

=================================
MAN PAGE FOR: memcpy
=================================

MEMCPY(3)                                                        Linux Programmer's Manual                                                        MEMCPY(3)

NAME
       memcpy - copy memory area

SYNOPSIS
       #include <string.h>

       void *memcpy(void *dest, const void *src, size_t n);

DESCRIPTION
       The memcpy() function copies n bytes from memory area src to memory area dest.  The memory areas must not overlap.  Use memmove(3) if the memory ar‐
       eas do overlap.

RETURN VALUE
       The memcpy() function returns a pointer to dest.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌──────────┬───────────────┬─────────┐
       │Interface │ Attribute     │ Value   │
       ├──────────┼───────────────┼─────────┤
       │memcpy()  │ Thread safety │ MT-Safe │
       └──────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

NOTES
       Failure to observe the requirement that the memory areas do not overlap has been the source of significant bugs.  (POSIX and the C standards are ex‐
       plicit  that employing memcpy() with overlapping areas produces undefined behavior.)  Most notably, in glibc 2.13 a performance optimization of mem‐
       cpy() on some platforms (including x86-64) included changing the order in which bytes were copied from src to dest.

       This change revealed breakages in a number of applications that performed copying with overlapping areas.  Under the  previous  implementation,  the
       order in which the bytes were copied had fortuitously hidden the bug, which was revealed when the copying order was reversed.  In glibc 2.14, a ver‐
       sioned symbol was added so that old binaries (i.e., those linked against glibc versions earlier than 2.14) employed a memcpy()  implementation  that
       safely handles the overlapping buffers case (by providing an "older" memcpy() implementation that was aliased to memmove(3)).

SEE ALSO
       bcopy(3), bstring(3), memccpy(3), memmove(3), mempcpy(3), strcpy(3), strncpy(3), wmemcpy(3)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

                                                                         2017-09-15                                                               MEMCPY(3)

=================================
MAN PAGE FOR: memmove
=================================

MEMMOVE(3)                                                       Linux Programmer's Manual                                                       MEMMOVE(3)

NAME
       memmove - copy memory area

SYNOPSIS
       #include <string.h>

       void *memmove(void *dest, const void *src, size_t n);

DESCRIPTION
       The  memmove()  function  copies  n bytes from memory area src to memory area dest.  The memory areas may overlap: copying takes place as though the
       bytes in src are first copied into a temporary array that does not overlap src or dest, and the bytes are then copied from the  temporary  array  to
       dest.

RETURN VALUE
       The memmove() function returns a pointer to dest.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌──────────┬───────────────┬─────────┐
       │Interface │ Attribute     │ Value   │
       ├──────────┼───────────────┼─────────┤
       │memmove() │ Thread safety │ MT-Safe │
       └──────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

SEE ALSO
       bcopy(3), bstring(3), memccpy(3), memcpy(3), strcpy(3), strncpy(3), wmemmove(3)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2017-03-13                                                              MEMMOVE(3)

=================================
MAN PAGE FOR: memset
=================================

MEMSET(3)                                                        Linux Programmer's Manual                                                        MEMSET(3)

NAME
       memset - fill memory with a constant byte

SYNOPSIS
       #include <string.h>

       void *memset(void *s, int c, size_t n);

DESCRIPTION
       The memset() function fills the first n bytes of the memory area pointed to by s with the constant byte c.

RETURN VALUE
       The memset() function returns a pointer to the memory area s.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌──────────┬───────────────┬─────────┐
       │Interface │ Attribute     │ Value   │
       ├──────────┼───────────────┼─────────┤
       │memset()  │ Thread safety │ MT-Safe │
       └──────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

SEE ALSO
       bstring(3), bzero(3), swab(3), wmemset(3)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2017-03-13                                                               MEMSET(3)

=================================
MAN PAGE FOR: putchar_fd
=================================

No manual entry found for putchar_fd

=================================
MAN PAGE FOR: putendl_fd
=================================

No manual entry found for putendl_fd

=================================
MAN PAGE FOR: putnbr_fd
=================================

No manual entry found for putnbr_fd

=================================
MAN PAGE FOR: putstr_fd
=================================

No manual entry found for putstr_fd

=================================
MAN PAGE FOR: split
=================================

Function name ft_split
Prototype char **ft_split(char const *s, char c);
Turn in files -
Parameters s: The string to be split.
c: The delimiter character.
Return value The array of new strings resulting from the split.
NULL if the allocation fails.
External functs. malloc, free
Description Allocates (with malloc(3)) and returns an array
of strings obtained by splitting ’s’ using the
character ’c’ as a delimiter. The array must end
with a NULL pointer.

=================================
MAN PAGE FOR: strchr
=================================

STRCHR(3)                                                        Linux Programmer's Manual                                                        STRCHR(3)

NAME
       strchr, strrchr, strchrnul - locate character in string

SYNOPSIS
       #include <string.h>

       char *strchr(const char *s, int c);

       char *strrchr(const char *s, int c);

       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <string.h>

       char *strchrnul(const char *s, int c);

DESCRIPTION
       The strchr() function returns a pointer to the first occurrence of the character c in the string s.

       The strrchr() function returns a pointer to the last occurrence of the character c in the string s.

       The  strchrnul()  function  is  like strchr() except that if c is not found in s, then it returns a pointer to the null byte at the end of s, rather
       than NULL.

       Here "character" means "byte"; these functions do not work with wide or multibyte characters.

RETURN VALUE
       The strchr() and strrchr() functions return a pointer to the matched character or NULL if the character is not found.  The terminating null byte  is
       considered part of the string, so that if c is specified as '\0', these functions return a pointer to the terminator.

       The  strchrnul() function returns a pointer to the matched character, or a pointer to the null byte at the end of s (i.e., s+strlen(s)) if the char‐
       acter is not found.

VERSIONS
       strchrnul() first appeared in glibc in version 2.1.1.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌─────────────────────────────────┬───────────────┬─────────┐
       │Interface                        │ Attribute     │ Value   │
       ├─────────────────────────────────┼───────────────┼─────────┤
       │strchr(), strrchr(), strchrnul() │ Thread safety │ MT-Safe │
       └─────────────────────────────────┴───────────────┴─────────┘
CONFORMING TO
       strchr(), strrchr(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

       strchrnul() is a GNU extension.

SEE ALSO
       index(3), memchr(3), rindex(3), string(3), strlen(3), strpbrk(3), strsep(3), strspn(3), strstr(3), strtok(3), wcschr(3), wcsrchr(3)

COLOPHON
       This page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs,  and  the  latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2019-03-06                                                               STRCHR(3)

=================================
MAN PAGE FOR: strdup
=================================

STRDUP(3)                                                        Linux Programmer's Manual                                                        STRDUP(3)

NAME
       strdup, strndup, strdupa, strndupa - duplicate a string

SYNOPSIS
       #include <string.h>

       char *strdup(const char *s);

       char *strndup(const char *s, size_t n);
       char *strdupa(const char *s);
       char *strndupa(const char *s, size_t n);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       strdup():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE || _SVID_SOURCE
       strndup():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _GNU_SOURCE
       strdupa(), strndupa(): _GNU_SOURCE

DESCRIPTION
       The strdup() function returns a pointer to a new string which is a duplicate of the string s.  Memory for the new string is obtained with malloc(3),
       and can be freed with free(3).

       The strndup() function is similar, but copies at most n bytes.  If s is longer than n, only n bytes are copied, and a terminating null  byte  ('\0')
       is added.

       strdupa()  and  strndupa()  are similar, but use alloca(3) to allocate the buffer.  They are available only when using the GNU GCC suite, and suffer
       from the same limitations described in alloca(3).

RETURN VALUE
       On success, the strdup() function returns a pointer to the duplicated string.  It returns NULL if insufficient memory was available, with errno  set
       to indicate the cause of the error.

ERRORS
       ENOMEM Insufficient memory available to allocate duplicate string.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌────────────────────────────────┬───────────────┬─────────┐
       │Interface                       │ Attribute     │ Value   │
       ├────────────────────────────────┼───────────────┼─────────┤
       │strdup(), strndup(), strdupa(), │ Thread safety │ MT-Safe │
       │strndupa()                      │               │         │
       └────────────────────────────────┴───────────────┴─────────┘

CONFORMING TO
       strdup() conforms to SVr4, 4.3BSD, POSIX.1-2001.  strndup() conforms to POSIX.1-2008.  strdupa() and strndupa() are GNU extensions.

SEE ALSO
       alloca(3), calloc(3), free(3), malloc(3), realloc(3), string(3), wcsdup(3)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2019-03-06                                                               STRDUP(3)

=================================
MAN PAGE FOR: striteri
=================================

No manual entry found for striteri

=================================
MAN PAGE FOR: strjoin
=================================

No manual entry found for strjoin

=================================
MAN PAGE FOR: strlcat
=================================

STRLCPY(3bsd)                                                              LOCAL                                                              STRLCPY(3bsd)

NAME
     strlcpy, strlcat — size-bounded string copying and concatenation

LIBRARY
     Utility functions from BSD systems (libbsd, -lbsd)

SYNOPSIS
     #include <string.h>
     (See libbsd(7) for include usage.)

     size_t
     strlcpy(char *dst, const char *src, size_t size);

     size_t
     strlcat(char *dst, const char *src, size_t size);

DESCRIPTION
     The strlcpy() and strlcat() functions copy and concatenate strings respectively.  They are designed to be safer, more consistent, and less error prone
     replacements for strncpy(3) and strncat(3).  Unlike those functions, strlcpy() and strlcat() take the full size of the buffer (not just the length)
     and guarantee to NUL-terminate the result (as long as size is larger than 0 or, in the case of strlcat(), as long as there is at least one byte free
     in dst).  Note that a byte for the NUL should be included in size.  Also note that strlcpy() and strlcat() only operate on true “C” strings.  This
     means that for strlcpy() src must be NUL-terminated and for strlcat() both src and dst must be NUL-terminated.

     The strlcpy() function copies up to size - 1 characters from the NUL-terminated string src to dst, NUL-terminating the result.

     The strlcat() function appends the NUL-terminated string src to the end of dst.  It will append at most size - strlen(dst) - 1 bytes, NUL-terminating
     the result.

RETURN VALUES
     The strlcpy() and strlcat() functions return the total length of the string they tried to create.  For strlcpy() that means the length of src.  For
     strlcat() that means the initial length of dst plus the length of src.  While this may seem somewhat confusing, it was done to make truncation detec‐
     tion simple.

     Note, however, that if strlcat() traverses size characters without finding a NUL, the length of the string is considered to be size and the destina‐
     tion string will not be NUL-terminated (since there was no space for the NUL).  This keeps strlcat() from running off the end of a string.  In prac‐
     tice this should not happen (as it means that either size is incorrect or that dst is not a proper “C” string).  The check exists to prevent potential
     security problems in incorrect code.

EXAMPLES
     The following code fragment illustrates the simple case:

           char *s, *p, buf[BUFSIZ];

           ...

           (void)strlcpy(buf, s, sizeof(buf));
           (void)strlcat(buf, p, sizeof(buf));

     To detect truncation, perhaps while building a pathname, something like the following might be used:

           char *dir, *file, pname[MAXPATHLEN];

           ...

           if (strlcpy(pname, dir, sizeof(pname)) >= sizeof(pname))
                   goto toolong;
           if (strlcat(pname, file, sizeof(pname)) >= sizeof(pname))
                   goto toolong;

     Since it is known how many characters were copied the first time, things can be sped up a bit by using a copy instead of an append:

           char *dir, *file, pname[MAXPATHLEN];
           size_t n;

           ...

           n = strlcpy(pname, dir, sizeof(pname));
           if (n >= sizeof(pname))
                   goto toolong;
           if (strlcpy(pname + n, file, sizeof(pname) - n) >= sizeof(pname) - n)
                   goto toolong;

     However, one may question the validity of such optimizations, as they defeat the whole purpose of strlcpy() and strlcat().  As a matter of fact, the
     first version of this manual page got it wrong.

SEE ALSO
     snprintf(3), strncat(3), strncpy(3)

HISTORY
     The strlcpy() and strlcat() functions first appeared in OpenBSD 2.4, and made their appearance in FreeBSD 3.3.

BSD                                                                     May 31, 2007                                                                    BSD

=================================
MAN PAGE FOR: strlcpy
=================================

STRLCPY(3bsd)                                                              LOCAL                                                              STRLCPY(3bsd)

NAME
     strlcpy, strlcat — size-bounded string copying and concatenation

LIBRARY
     Utility functions from BSD systems (libbsd, -lbsd)

SYNOPSIS
     #include <string.h>
     (See libbsd(7) for include usage.)

     size_t
     strlcpy(char *dst, const char *src, size_t size);

     size_t
     strlcat(char *dst, const char *src, size_t size);

DESCRIPTION
     The strlcpy() and strlcat() functions copy and concatenate strings respectively.  They are designed to be safer, more consistent, and less error prone
     replacements for strncpy(3) and strncat(3).  Unlike those functions, strlcpy() and strlcat() take the full size of the buffer (not just the length)
     and guarantee to NUL-terminate the result (as long as size is larger than 0 or, in the case of strlcat(), as long as there is at least one byte free
     in dst).  Note that a byte for the NUL should be included in size.  Also note that strlcpy() and strlcat() only operate on true “C” strings.  This
     means that for strlcpy() src must be NUL-terminated and for strlcat() both src and dst must be NUL-terminated.

     The strlcpy() function copies up to size - 1 characters from the NUL-terminated string src to dst, NUL-terminating the result.

     The strlcat() function appends the NUL-terminated string src to the end of dst.  It will append at most size - strlen(dst) - 1 bytes, NUL-terminating
     the result.

RETURN VALUES
     The strlcpy() and strlcat() functions return the total length of the string they tried to create.  For strlcpy() that means the length of src.  For
     strlcat() that means the initial length of dst plus the length of src.  While this may seem somewhat confusing, it was done to make truncation detec‐
     tion simple.

     Note, however, that if strlcat() traverses size characters without finding a NUL, the length of the string is considered to be size and the destina‐
     tion string will not be NUL-terminated (since there was no space for the NUL).  This keeps strlcat() from running off the end of a string.  In prac‐
     tice this should not happen (as it means that either size is incorrect or that dst is not a proper “C” string).  The check exists to prevent potential
     security problems in incorrect code.

EXAMPLES
     The following code fragment illustrates the simple case:

           char *s, *p, buf[BUFSIZ];

           ...

           (void)strlcpy(buf, s, sizeof(buf));
           (void)strlcat(buf, p, sizeof(buf));

     To detect truncation, perhaps while building a pathname, something like the following might be used:

           char *dir, *file, pname[MAXPATHLEN];

           ...

           if (strlcpy(pname, dir, sizeof(pname)) >= sizeof(pname))
                   goto toolong;
           if (strlcat(pname, file, sizeof(pname)) >= sizeof(pname))
                   goto toolong;

     Since it is known how many characters were copied the first time, things can be sped up a bit by using a copy instead of an append:

           char *dir, *file, pname[MAXPATHLEN];
           size_t n;

           ...

           n = strlcpy(pname, dir, sizeof(pname));
           if (n >= sizeof(pname))
                   goto toolong;
           if (strlcpy(pname + n, file, sizeof(pname) - n) >= sizeof(pname) - n)
                   goto toolong;

     However, one may question the validity of such optimizations, as they defeat the whole purpose of strlcpy() and strlcat().  As a matter of fact, the
     first version of this manual page got it wrong.

SEE ALSO
     snprintf(3), strncat(3), strncpy(3)

HISTORY
     The strlcpy() and strlcat() functions first appeared in OpenBSD 2.4, and made their appearance in FreeBSD 3.3.

BSD                                                                     May 31, 2007                                                                    BSD

=================================
MAN PAGE FOR: strlen
=================================

STRLEN(3)                                                        Linux Programmer's Manual                                                        STRLEN(3)

NAME
       strlen - calculate the length of a string

SYNOPSIS
       #include <string.h>

       size_t strlen(const char *s);

DESCRIPTION
       The strlen() function calculates the length of the string pointed to by s, excluding the terminating null byte ('\0').

RETURN VALUE
       The strlen() function returns the number of bytes in the string pointed to by s.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌──────────┬───────────────┬─────────┐
       │Interface │ Attribute     │ Value   │
       ├──────────┼───────────────┼─────────┤
       │strlen()  │ Thread safety │ MT-Safe │
       └──────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, C89, C99, C11, SVr4, 4.3BSD.

SEE ALSO
       string(3), strnlen(3), wcslen(3), wcsnlen(3)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2019-03-06                                                               STRLEN(3)

=================================
MAN PAGE FOR: strmapi
=================================

Function name ft_strmapi
Prototype char *ft_strmapi(char const *s, char (*f)(unsigned
int, char));
Turn in files -
Parameters s: The string on which to iterate.
f: The function to apply to each character.
Return value The string created from the successive applications
of ’f’.
Returns NULL if the allocation fails.
External functs. malloc
Description Applies the function ’f’ to each character of the
string ’s’, and passing its index as first argument
to create a new string (with malloc(3)) resulting
from successive applications of ’f’.

=================================
MAN PAGE FOR: strncmp
=================================

STRCMP(3)                                                        Linux Programmer's Manual                                                        STRCMP(3)

NAME
       strcmp, strncmp - compare two strings

SYNOPSIS
       #include <string.h>

       int strcmp(const char *s1, const char *s2);

       int strncmp(const char *s1, const char *s2, size_t n);

DESCRIPTION
       The  strcmp()  function  compares  the two strings s1 and s2.  The locale is not taken into account (for a locale-aware comparison, see strcoll(3)).
       The comparison is done using unsigned characters.

       strcmp() returns an integer indicating the result of the comparison, as follows:

       • 0, if the s1 and s2 are equal;

       • a negative value if s1 is less than s2;

       • a positive value if s1 is greater than s2.

       The strncmp() function is similar, except it compares only the first (at most) n bytes of s1 and s2.

RETURN VALUE
       The strcmp() and strncmp() functions return an integer less than, equal to, or greater than zero if s1 (or the first n bytes thereof) is found,  re‐
       spectively, to be less than, to match, or be greater than s2.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌────────────────────┬───────────────┬─────────┐
       │Interface           │ Attribute     │ Value   │
       ├────────────────────┼───────────────┼─────────┤
       │strcmp(), strncmp() │ Thread safety │ MT-Safe │
       └────────────────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

NOTES
       POSIX.1 specifies only that:

              The  sign of a nonzero return value shall be determined by the sign of the difference between the values of the first pair of bytes (both in‐
              terpreted as type unsigned char) that differ in the strings being compared.

       In glibc, as in most other implementations, the return value is the arithmetic result of subtracting the last compared byte in s2 from the last com‐
       pared byte in s1.  (If the two characters are equal, this difference is 0.)

EXAMPLES
       The  program  below  can  be  used  to  demonstrate the operation of strcmp() (when given two arguments) and strncmp() (when given three arguments).
       First, some examples using strcmp():

           $ ./string_comp ABC ABC
           <str1> and <str2> are equal
           $ ./string_comp ABC AB      # 'C' is ASCII 67; 'C' - ' ' = 67
           <str1> is greater than <str2> (67)
           $ ./string_comp ABA ABZ     # 'A' is ASCII 65; 'Z' is ASCII 90
           <str1> is less than <str2> (-25)
           $ ./string_comp ABJ ABC
           <str1> is greater than <str2> (7)
           $ ./string_comp $'\201' A   # 0201 - 0101 = 0100 (or 64 decimal)
           <str1> is greater than <str2> (64)

       The last example uses bash(1)-specific syntax to produce a string containing an 8-bit ASCII code; the result demonstrates that the string comparison
       uses unsigned characters.

       And then some examples using strncmp():

           $ ./string_comp ABC AB 3
           <str1> is greater than <str2> (67)
           $ ./string_comp ABC AB 2
           <str1> and <str2> are equal in the first 2 bytes

   Program source

       /* string_comp.c

          Licensed under GNU General Public License v2 or later.
       */
       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>

       int
       main(int argc, char *argv[])
       {
           int res;

           if (argc < 3) {
               fprintf(stderr, "Usage: %s <str1> <str2> [<len>]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (argc == 3)
               res = strcmp(argv[1], argv[2]);
           else
               res = strncmp(argv[1], argv[2], atoi(argv[3]));

           if (res == 0) {
               printf("<str1> and <str2> are equal");
               if (argc > 3)
                   printf(" in the first %d bytes\n", atoi(argv[3]));
               printf("\n");
           } else if (res < 0) {
               printf("<str1> is less than <str2> (%d)\n", res);
           } else {
               printf("<str1> is greater than <str2> (%d)\n", res);
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       bcmp(3), memcmp(3), strcasecmp(3), strcoll(3), string(3), strncasecmp(3), strverscmp(3), wcscmp(3), wcsncmp(3), ascii(7)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

                                                                         2020-04-11                                                               STRCMP(3)

=================================
MAN PAGE FOR: strnstr
=================================

STRSTR(3bsd)                                                               LOCAL                                                               STRSTR(3bsd)

NAME
     strnstr — locate a substring in a string

LIBRARYFunction name ft_strmapi
Prototype char *ft_strmapi(char const *s, char (*f)(unsigned
int, char));
Turn in files -
Parameters s: The string on which to iterate.
f: The function to apply to each character.
Return value The string created from the successive applications
of ’f’.
Returns NULL if the allocation fails.
External functs. malloc
Description Applies the function ’f’ to each character of the
string ’s’, and passing its index as first argument
to create a new string (with malloc(3)) resulting
from successive applications of ’f’.
     Utility functions from BSD systems (libbsd, -lbsd)

SYNOPSIS
     #include <string.h>
     (See libbsd(7) for include usage.)

     char *
     strnstr(const char *big, const char *little, size_t len);

DESCRIPTION
     The strnstr() function locates the first occurrence of the null-terminated string little in the string big, where not more than len characters are
     searched.  Characters that appear after a ‘\0’ character are not searched.  Since the strnstr() function is a FreeBSD specific API, it should only be
     used when portability is not a concern.

RETURN VALUES
     If little is an empty string, big is returned; if little occurs nowhere in big, NULL is returned; otherwise a pointer to the first character of the
     first occurrence of little is returned.

EXAMPLES
     The following sets the pointer ptr to NULL, because only the first 4 characters of largestring are searched:

           const char *largestring = "Foo Bar Baz";
           const char *smallstring = "Bar";
           char *ptr;

           ptr = strnstr(largestring, smallstring, 4);

SEE ALSO
     strstr(3), strcasestr(3), memchr(3), memmem(3), strchr(3), strcspn(3), strpbrk(3), strrchr(3), strsep(3), strspn(3), strtok(3), wcsstr(3)

BSD                                                                   October 11, 2001                                                                  BSD

=================================
MAN PAGE FOR: strrchr
=================================

STRCHR(3)                                                        Linux Programmer's Manual                                                        STRCHR(3)

NAME
       strchr, strrchr, strchrnul - locate character in string

SYNOPSIS
       #include <string.h>

       char *strchr(const char *s, int c);

       char *strrchr(const char *s, int c);

       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <string.h>

       char *strchrnul(const char *s, int c);

DESCRIPTION
       The strchr() function returns a pointer to the first occurrence of the character c in the string s.

       The strrchr() function returns a pointer to the last occurrence of the character c in the string s.

       The  strchrnul()  function  is  like strchr() except that if c is not found in s, then it returns a pointer to the null byte at the end of s, rather
       than NULL.

       Here "character" means "byte"; these functions do not work with wide or multibyte characters.

RETURN VALUE
       The strchr() and strrchr() functions return a pointer to the matched character or NULL if the character is not found.  The terminating null byte  is
       considered part of the string, so that if c is specified as '\0', these functions return a pointer to the terminator.

       The  strchrnul() function returns a pointer to the matched character, or a pointer to the null byte at the end of s (i.e., s+strlen(s)) if the char‐
       acter is not found.

VERSIONS
       strchrnul() first appeared in glibc in version 2.1.1.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌─────────────────────────────────┬───────────────┬─────────┐
       │Interface                        │ Attribute     │ Value   │
       ├─────────────────────────────────┼───────────────┼─────────┤
       │strchr(), strrchr(), strchrnul() │ Thread safety │ MT-Safe │
       └─────────────────────────────────┴───────────────┴─────────┘
CONFORMING TO
       strchr(), strrchr(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

       strchrnul() is a GNU extension.

SEE ALSO
       index(3), memchr(3), rindex(3), string(3), strlen(3), strpbrk(3), strsep(3), strspn(3), strstr(3), strtok(3), wcschr(3), wcsrchr(3)

COLOPHON
       This page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs,  and  the  latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2019-03-06                                                               STRCHR(3)

=================================
MAN PAGE FOR: strtrim
=================================

No manual entry found for strtrim

=================================
MAN PAGE FOR: substr
=================================

No manual entry found for substr

=================================
MAN PAGE FOR: tolower
=================================

TOUPPER(3)                                                       Linux Programmer's Manual                                                       TOUPPER(3)

NAME
       toupper, tolower, toupper_l, tolower_l - convert uppercase or lowercase

SYNOPSIS
       #include <ctype.h>

       int toupper(int c);
       int tolower(int c);

       int toupper_l(int c, locale_t locale);
       int tolower_l(int c, locale_t locale);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       toupper_l(), tolower_l():
           Since glibc 2.10:
                  _XOPEN_SOURCE >= 700
           Before glibc 2.10:
                  _GNU_SOURCE

DESCRIPTION
       These functions convert lowercase letters to uppercase, and vice versa.

       If  c is a lowercase letter, toupper() returns its uppercase equivalent, if an uppercase representation exists in the current locale.  Otherwise, it
       returns c.  The toupper_l() function performs the same task, but uses the locale referred to by the locale handle locale.

       If c is an uppercase letter, tolower() returns its lowercase equivalent, if a lowercase representation exists in the current locale.  Otherwise,  it
       returns c.  The tolower_l() function performs the same task, but uses the locale referred to by the locale handle locale.

       If c is neither an unsigned char value nor EOF, the behavior of these functions is undefined.

       The  behavior  of  toupper_l()  and  tolower_l() is undefined if locale is the special locale object LC_GLOBAL_LOCALE (see duplocale(3)) or is not a
       valid locale object handle.

RETURN VALUE
       The value returned is that of the converted letter, or c if the conversion was not possible.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌─────────────────────────┬───────────────┬─────────┐
       │Interface                │ Attribute     │ Value   │
       ├─────────────────────────┼───────────────┼─────────┤
       │toupper(), tolower(),    │ Thread safety │ MT-Safe │
       │toupper_l(), tolower_l() │               │         │
       └─────────────────────────┴───────────────┴─────────┘
CONFORMING TO
       toupper(), tolower(): C89, C99, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       toupper_l(), tolower_l(): POSIX.1-2008.

NOTES
       The standards require that the argument c for these functions is either EOF or a value that is representable in the type unsigned char.  If the  ar‐
       gument c is of type char, it must be cast to unsigned char, as in the following example:

           char c;
           ...
           res = toupper((unsigned char) c);

       This is necessary because char may be the equivalent signed char, in which case a byte where the top bit is set would be sign extended when convert‐
       ing to int, yielding a value that is outside the range of unsigned char.

       The details of what constitutes an uppercase or lowercase letter depend on the locale.  For example, the default "C" locale does not know about  um‐
       lauts, so no conversion is done for them.

       In some non-English locales, there are lowercase letters with no corresponding uppercase equivalent; the German sharp s is one example.

SEE ALSO
       isalpha(3), newlocale(3), setlocale(3), towlower(3), towupper(3), uselocale(3), locale(7)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2017-09-15                                                              TOUPPER(3)

=================================
MAN PAGE FOR: toupper
=================================

TOUPPER(3)                                                       Linux Programmer's Manual                                                       TOUPPER(3)

NAME
       toupper, tolower, toupper_l, tolower_l - convert uppercase or lowercase

SYNOPSIS
       #include <ctype.h>

       int toupper(int c);
       int tolower(int c);

       int toupper_l(int c, locale_t locale);
       int tolower_l(int c, locale_t locale);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       toupper_l(), tolower_l():
           Since glibc 2.10:
                  _XOPEN_SOURCE >= 700
           Before glibc 2.10:
                  _GNU_SOURCE

DESCRIPTION
       These functions convert lowercase letters to uppercase, and vice versa.

       If  c is a lowercase letter, toupper() returns its uppercase equivalent, if an uppercase representation exists in the current locale.  Otherwise, it
       returns c.  The toupper_l() function performs the same task, but uses the locale referred to by the locale handle locale.

       If c is an uppercase letter, tolower() returns its lowercase equivalent, if a lowercase representation exists in the current locale.  Otherwise,  it
       returns c.  The tolower_l() function performs the same task, but uses the locale referred to by the locale handle locale.

       If c is neither an unsigned char value nor EOF, the behavior of these functions is undefined.

       The  behavior  of  toupper_l()  and  tolower_l() is undefined if locale is the special locale object LC_GLOBAL_LOCALE (see duplocale(3)) or is not a
       valid locale object handle.

RETURN VALUE
       The value returned is that of the converted letter, or c if the conversion was not possible.

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌─────────────────────────┬───────────────┬─────────┐
       │Interface                │ Attribute     │ Value   │
       ├─────────────────────────┼───────────────┼─────────┤
       │toupper(), tolower(),    │ Thread safety │ MT-Safe │
       │toupper_l(), tolower_l() │               │         │
       └─────────────────────────┴───────────────┴─────────┘
CONFORMING TO
       toupper(), tolower(): C89, C99, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       toupper_l(), tolower_l(): POSIX.1-2008.

NOTES
       The standards require that the argument c for these functions is either EOF or a value that is representable in the type unsigned char.  If the  ar‐
       gument c is of type char, it must be cast to unsigned char, as in the following example:

           char c;
           ...
           res = toupper((unsigned char) c);

       This is necessary because char may be the equivalent signed char, in which case a byte where the top bit is set would be sign extended when convert‐
       ing to int, yielding a value that is outside the range of unsigned char.

       The details of what constitutes an uppercase or lowercase letter depend on the locale.  For example, the default "C" locale does not know about  um‐
       lauts, so no conversion is done for them.

       In some non-English locales, there are lowercase letters with no corresponding uppercase equivalent; the German sharp s is one example.

SEE ALSO
       isalpha(3), newlocale(3), setlocale(3), towlower(3), towupper(3), uselocale(3), locale(7)

COLOPHON
       This  page  is  part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

GNU                                                                      2017-09-15                                                              TOUPPER(3)

